{"version":3,"file":"dvDownloadManager.js","mappings":"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","sources":["webpack://dvDownloadManager/webpack/universalModuleDefinition","webpack://dvDownloadManager/webpack/bootstrap","webpack://dvDownloadManager/webpack/runtime/define property getters","webpack://dvDownloadManager/webpack/runtime/hasOwnProperty shorthand","webpack://dvDownloadManager/webpack/runtime/make namespace object","webpack://dvDownloadManager/./src/strategies.ts","webpack://dvDownloadManager/./src/downloadManager.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"dvDownloadManager\"] = factory();\n\telse\n\t\troot[\"dvDownloadManager\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import type { addingQueueItem, downloadQueueItem } from './types.d'\n\n/**\n * Concatenate the adding queue to the download queue\n */\nfunction concat(adding: addingQueueItem[], actual: downloadQueueItem[]) {\n  adding.forEach((item) => {\n    item.imageIds.forEach((imageId) => {\n      actual.push({\n        studyId: item.studyId,\n        seriesId: item.seriesId,\n        imageId: imageId\n      })\n    })\n  })\n  return actual\n}\n\n/**\n * Create a new queue alternating series\n */\nfunction alternate(adding: addingQueueItem[], actual: downloadQueueItem[]) {\n  let newQueue: downloadQueueItem[] = []\n\n  let seriesIds = new Set(actual.map((item) => item.seriesId))\n  adding.forEach((item) => seriesIds.add(item.seriesId))\n  let seriesIdsArray = Array.from(seriesIds)\n\n  let addingObjectsArray: downloadQueueItem[] = adding\n    .map((object) =>\n      object.imageIds.map((imageId) => ({\n        studyId: object.studyId,\n        seriesId: object.seriesId,\n        imageId\n      }))\n    )\n    .flat()\n\n  let allImages = addingObjectsArray.concat(actual)\n  let numberOfTotalImages = allImages.length\n\n  for (let i = 0; i < numberOfTotalImages; i++) {\n    let seriesToPush = seriesIdsArray[i % seriesIds.size]\n\n    let imageToPushIndex = allImages.findIndex((item) => item.seriesId === seriesToPush)\n    let imageToPush = allImages.splice(imageToPushIndex, 1).pop()\n\n    if (!imageToPush) {\n      throw new Error('imageToPush is undefined')\n    }\n\n    newQueue.push(imageToPush)\n  }\n\n  return newQueue\n}\n\nexport default { concat, alternate }\n","import type {\n  downloadQueueItem,\n  addingQueueItem,\n  removingQueueItem,\n  seriesData\n} from \"./types.d\";\n\nimport strategiesFns from \"./strategies\";\n\n/**\n * DownloadManager class\n */\nexport class DownloadManager {\n  /**\n   * The real download queue\n   */\n  private downloadQueue: downloadQueueItem[] = [];\n  /**\n   * The queue of series to add to the download queue\n   */\n  private addingQueue: addingQueueItem[] = [];\n  /**\n   * The queue of series to remove from the download queue\n   */\n  private removingQueue: removingQueueItem[] = [];\n  /**\n   * Token to freeze the production of new download slots\n   */\n  private freeze = false;\n  /**\n   * The strategy to use to create the download queue\n   */\n  private strategy: keyof typeof strategiesFns;\n  /**\n   * If true, the download manager will log to the console\n   */\n  private verbose: boolean = false;\n  /**\n   * The data of the series in the download manager, used to keep track of download progress\n   */\n  private seriesData: seriesData = {};\n\n  constructor(\n    strategy: keyof typeof strategiesFns = \"concat\",\n    verbose?: boolean\n  ) {\n    this.strategy = strategy;\n    this.verbose = verbose ?? false;\n  }\n\n  /**\n   * Download is on going if there are instances in the download queue\n   * and isDownloading is true for at least one series\n   * (isDownloading is set to true when the first instance of a series\n   * is popped from the download queue)\n   **/\n  get isDownloading() {\n    return (\n      Object.values(this.seriesData).reduce(\n        (acc, curr) => curr.isDownloading || acc,\n        false\n      ) && this.downloadQueue.length > 0\n    );\n  }\n\n  private updateIsDownloading(slot: downloadQueueItem[]) {\n    const seriesIds = new Set(slot.map(item => item.seriesId));\n    [...seriesIds].forEach(seriesId => {\n      const remaining = this.downloadQueue.filter(\n        item => item.seriesId === seriesId\n      ).length;\n      if (remaining === 0) {\n        delete this.seriesData[seriesId];\n      } else {\n        this.seriesData[seriesId].isDownloading = true;\n      }\n    });\n  }\n\n  /**\n   * Add a new series in the download manager\n   * @returns True if the series was added, false otherwise\n   */\n  addSeries(seriesId: string, studyId: string, imageIds: string[]) {\n    // check that the series is not already in the seriesData\n    // TODO what if I want to add other slices for a series ? we could use s Set for the imagesIds\n    if (seriesId in this.seriesData) {\n      console.warn(`Series ${seriesId} is already in the download manager`);\n      return false;\n    }\n    // otherwise add it to the adding queue\n    this.addingQueue.push({\n      seriesId: seriesId,\n      studyId: studyId,\n      imageIds: imageIds\n    });\n    this.seriesData[seriesId] = {\n      numberOfImages: imageIds.length,\n      isDownloading: false\n    };\n    this.seriesData[seriesId].numberOfImages = imageIds.length;\n    this.seriesData[seriesId].isDownloading = false;\n    this.reworkQueue();\n    return true;\n  }\n\n  // TODO return boolean if series was removed\n  removeSeries(seriesId: string) {\n    // directly remove from download queue (you don't add and remove the same series in the same time)\n    this.addingQueue = this.addingQueue.filter(\n      item => item.seriesId !== seriesId\n    );\n    this.removingQueue.push(seriesId);\n    delete this.seriesData[seriesId];\n    this.reworkQueue();\n  }\n\n  /**\n   * Rework the download queue after each request,\n   * at the moment simply adds all imagesIds to the download queue\n   * in the same order as they were added to the working queue\n   */\n  reworkQueue() {\n    // block requests\n    this.freeze = true;\n\n    // apply \"remove\" modifications\n    this.removingQueue.forEach(seriesId => {\n      this.downloadQueue = this.downloadQueue.filter(\n        item => item.seriesId !== seriesId\n      );\n    });\n\n    // apply \"add\" modifications\n    this.downloadQueue = strategiesFns[this.strategy](\n      this.addingQueue,\n      this.downloadQueue\n    );\n\n    this.addingQueue = [];\n    this.removingQueue = [];\n\n    if (this.verbose) console.log(\"downloadQueue\", this.downloadQueue);\n\n    // unblock requests\n    this.freeze = false;\n  }\n\n  /**\n   * Returns the status of the requested series\n   */\n  getStatus(seriesId: string) {\n    const remaining = this.downloadQueue.filter(\n      item => item.seriesId === seriesId\n    ).length;\n    const initial = this.seriesData[seriesId]?.numberOfImages;\n    return remaining ? { remaining, initial } : null;\n  }\n\n  /**\n   * Returns the status of all series\n   */\n  getOverallStatus() {\n    const seriesIds = Object.keys(this.seriesData);\n    const obj = Object.fromEntries(\n      seriesIds.map((key, index) => [key, this.getStatus(key)])\n    );\n    return obj;\n  }\n\n  /**\n   * Returns the next slot of images to download\n   * @param slotDimension {number} number of images to download\n   * @returns {array<downloadQueueItem>}\n   */\n  // TODO make private (fix tests)\n  getNextSlot(slotDimension: number) {\n    if (this.freeze) {\n      return null;\n    }\n    const nextSlot = this.downloadQueue.splice(0, slotDimension);\n    this.updateIsDownloading(nextSlot);\n    if (this.verbose) console.log(\"nextSlot\", nextSlot);\n    return nextSlot;\n  }\n\n  async getNextSlotAsync(slotDimension: number) {\n    return new Promise((resolve, reject) => {\n      const interval = setInterval(() => {\n        const nextSlot = this.getNextSlot(slotDimension);\n        if (nextSlot) {\n          clearInterval(interval);\n          resolve(nextSlot);\n        }\n      }, 20);\n    });\n  }\n}\n"],"names":[],"sourceRoot":""}